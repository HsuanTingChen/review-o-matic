#!/usr/bin/env python3

from reviewer import Reviewer
from gerrit import Gerrit, GerritRevision, GerritMessage

import argparse
import datetime
import random
import re
import requests
import sys
import time
import urllib

class Troll(object):
  STRING_HEADER='''
-- Automated message --
'''
  STRING_SUCCESS='''
This change does not differ from its upstream source. It is certified {}
by review-o-matic!
'''
  STRING_MISSING_FIELDS='''
Your commit message is missing the following required field(s):
    {}
'''
  STRING_MISSING_HASH='''
Your commit message is missing the upstream commit hash. It should be in the
form:
    (cherry picked from commit <commit SHA>)
'''
  STRING_UNSUCCESSFUL_HEADER='''
This patch differs from the source commit.

'''
  STRING_UPSTREAM_DIFF='''
Since this is an UPSTREAM labeled patch, it shouldn't. Either this reviewing
script is incorrect (totally possible, pls send patches!), or something changed
when this was backported. If the backport required changes, please consider
using the BACKPORT label with a description of you downstream changes in your
commit message.
'''
  STRING_BACKPORT_DIFF='''
This is expected, and this message is posted to make reviewing backports easier.
'''
  STRING_FROMGIT_DIFF='''
This may be expected, this message is posted to make reviewing backports easier.
'''
  STRING_UNSUCCESSFUL_FOOTER='''
Below is a diff of the upstream patch referenced in this commit message, vs this
patch.

'''
  STRING_FOOTER='''
---
Details available at https://github.com/atseanpaul/review-o-matic
'''

  def __init__(self, url, args):
    self.url = url
    self.args = args
    self.gerrit = Gerrit(url)
    self.tag = 'autogenerated:review-o-matic'
    self.swag = ['Rocky Mountain Cold', 'Frrrresh', 'Crisper Than Cabbage',
                 'Awesome', 'Ahhhmazing', 'Cool As A Cucumber',
                 'Gold Jerry! Gold!', 'Most Excellent']
    self.blacklist = []

  def do_review(self, change, msg, notify, vote):
    if not self.args.dry_run:
      self.gerrit.review(change, self.tag, msg, notify, vote_code_review=vote)

  def handle_successful_review(self, change):
    print('Adding successful review for change {}'.format(change.url()))

    msg = self.STRING_HEADER
    msg += self.STRING_SUCCESS.format(random.choice(self.swag))
    msg += self.STRING_FOOTER
    self.do_review(change, msg, True, 1)


  def handle_missing_fields_review(self, change, fields):
    print('Adding missing fields review for change {}'.format(change.url()))

    msg = self.STRING_HEADER
    missing = []
    if not fields['bug']:
      missing.append('BUG=')
    if not fields['test']:
      missing.append('TEST=')
    if not fields['sob']:
      cur_rev = change.current_revision
      missing.append('Signed-off-by: {} <{}>'.format(cur_rev.uploader_name,
                                                     cur_rev.uploader_email))

    msg += self.STRING_MISSING_FIELDS.format(', '.join(missing))
    msg += self.STRING_FOOTER
    self.do_review(change, msg, True, 1)

  def handle_missing_hash_review(self, change):
    print('Adding missing hash review for change {}'.format(change.url()))

    msg = self.STRING_HEADER
    msg += self.STRING_MISSING_HASH
    msg += self.STRING_FOOTER
    self.do_review(change, msg, True, 1)

  def handle_unsuccessful_review(self, change, prefix, result):
    vote = 0
    notify = False

    msg = self.STRING_HEADER
    msg += self.STRING_UNSUCCESSFUL_HEADER

    if prefix == 'UPSTREAM':
      vote = -1
      notify = True
      msg += self.STRING_UPSTREAM_DIFF
    elif prefix == 'BACKPORT':
      msg += self.STRING_BACKPORT_DIFF
    elif prefix == 'FROMGIT':
      msg += self.STRING_FROMGIT_DIFF

    msg += self.STRING_UNSUCCESSFUL_FOOTER

    for l in result:
      msg += '{}\n'.format(l)

    msg += self.STRING_FOOTER

    print('Adding unsuccessful review (vote={}) for change {}'.format(vote,
          change.url()))

    self.do_review(change, msg, notify, vote)


  def get_changes(self, prefix):
    message = '{}:'.format(prefix)
    after = datetime.date.today() - datetime.timedelta(days=30)
    changes = self.gerrit.query_changes(status='open', message=message,
                    after=after, project='chromiumos/third_party/kernel')
    return changes

  def print_error(self, error):
    if self.args.verbose:
      sys.stderr.write('\n')
    sys.stderr.write(error)

  def process_changes(self, prefix, changes):
    rev = Reviewer(git_dir=self.args.git_dir, verbose=self.args.verbose,
                   chatty=self.args.chatty)
    num_changes = len(changes)
    cur_change = 1
    line_feed = False
    for c in changes:
      cur_rev = c.current_revision

      if self.args.verbose:
        sys.stdout.write('{}Processing change {}/{}'.format(
                            '\r' if line_feed else '',
                            cur_change, num_changes))
        cur_change += 1

      line_feed = True

      if c in self.blacklist:
        continue

      if not c.subject.startswith(prefix) or 'FROMLIST' in c.subject:
        continue

      skip = False
      for m in c.messages:
        if m.tag == self.tag and m.revision_num == cur_rev.number:
          skip = True
      if skip:
        continue

      line_feed = False
      if self.args.verbose:
        print('')

      fields={'sob':False, 'bug':False, 'test':False}
      sob_re = re.compile('Signed-off-by:\s+{}\s+<{}>'.format(
                                cur_rev.uploader_name, cur_rev.uploader_email))
      for l in cur_rev.commit_message.splitlines():
        if l.startswith('BUG='):
          fields['bug'] = True
          continue
        if l.startswith('TEST='):
          fields['test'] = True
          continue
        if sob_re.match(l):
          fields['sob'] = True
          continue

      if not fields['bug'] or not fields['test'] or not fields['sob']:
        self.handle_missing_fields_review(c, fields)
        continue

      gerrit_patch = rev.get_commit_from_remote('cros', cur_rev.ref)

      upstream_sha = rev.get_cherry_pick_sha_from_patch(gerrit_patch)
      if not upstream_sha:
        self.handle_missing_hash_review(c)
        continue

      try:
        upstream_patch = rev.get_commit_from_sha(upstream_sha)
      except:
        self.print_error(
            'ERROR: Cherry pick sha not found in git for {}\n'.format(c))
        self.blacklist.append(c)
        continue

      result = rev.compare_diffs(upstream_patch, gerrit_patch)
      if len(result) == 0:
        self.handle_successful_review(c)
        continue

      self.handle_unsuccessful_review(c, prefix, result)

    if self.args.verbose:
      print('')


  def run(self):
    while True:
      try:
        prefixes = ['UPSTREAM', 'BACKPORT', 'FROMGIT']
        subsystems = ['drm', 'gpu', 'msm', 'dt-bindings']
        for p in prefixes:
          changes = self.get_changes(p)
          if self.args.verbose:
            print('{} changes for prefix {}'.format(len(changes), p))
          self.process_changes(p, changes)
        if not self.args.daemon:
          break
        if self.args.verbose:
          print('Finished! Going to sleep until next run')

      except requests.exceptions.HTTPError as e:
        self.print_error('HTTPError ({})\n'.format(e.response.status_code))
        time.sleep(60)

      time.sleep(120)


def main():
  parser = argparse.ArgumentParser(description='Troll gerrit reviews')
  parser.add_argument('--git-dir', default=None, help='Path to git directory')
  parser.add_argument('--verbose', help='print commits', action='store_true')
  parser.add_argument('--chatty', help='print diffs', action='store_true')
  parser.add_argument('--daemon', action='store_true',
    help='Run in daemon mode, for continuous trolling')
  parser.add_argument('--dry-run', action='store_true', default=False,
                      help='skip the review step')
  args = parser.parse_args()

  troll = Troll('https://chromium-review.googlesource.com', args)
  troll.run()

if __name__ == '__main__':
  sys.exit(main())
